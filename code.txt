/src/config/index.js
require('dotenv').config();

module.exports = {
  kafka: {
    brokers: process.env.KAFKA_BROKERS.split(','),
    topicTransactions: process.env.KAFKA_TOPIC_TRANSACTIONS,
    groupId: process.env.KAFKA_GROUP_ID,
  },
  app: {
    port: process.env.PORT || 3000,
    logLevel: process.env.LOG_LEVEL || 'info',
  },
};

/src/controllers/fraudController.js
const fraudStorage = require('../models/fraudStorage');
const logger = require('../utils/logger');

class FraudController {
  async getAllFrauds(req, res) {
    try {
      const frauds = await fraudStorage.getAllFrauds();
      res.json(frauds);
    } catch (error) {
      logger.error('Error fetching all frauds', { error: error.message });
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  async getFraudsByUser(req, res) {
    try {
      const { userId } = req.params;
      const frauds = await fraudStorage.getFraudsByUser(userId);
      
      if (frauds.length === 0) {
        return res.status(404).json({ 
          message: 'No frauds found for this user' 
        });
      }
      
      res.json(frauds);
    } catch (error) {
      logger.error('Error fetching user frauds', { 
        userId: req.params.userId,
        error: error.message 
      });
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  healthCheck(req, res) {
    res.json({ 
      status: 'healthy',
      timestamp: new Date().toISOString(),
    });
  }
}

module.exports = new FraudController();

/src/kafka/consumer.js
const { Kafka } = require('kafkajs');
const logger = require('../utils/logger');
const config = require('../config');
const fraudDetectionService = require('../services/fraudDetectionService');

class KafkaConsumer {
  constructor() {
    this.kafka = new Kafka({
      brokers: config.kafka.brokers,
      clientId: 'fraud-detection-service',
    });
    
    this.consumer = this.kafka.consumer({ groupId: config.kafka.groupId });
    this.isConnected = false;
  }

  async connect() {
    try {
      await this.consumer.connect();
      await this.consumer.subscribe({ 
        topic: config.kafka.topicTransactions, 
        fromBeginning: false 
      });
      
      this.isConnected = true;
      logger.info('Kafka consumer connected and subscribed');
      
      await this.consumer.run({
        eachMessage: async ({ topic, partition, message }) => {
          try {
            const transaction = JSON.parse(message.value.toString());
            logger.info(`Received transaction: ${transaction.transactionId}`);
            
            // Process transaction for fraud detection
            await fraudDetectionService.processTransaction(transaction);
          } catch (error) {
            logger.error(`Error processing message: ${error.message}`, {
              topic,
              partition,
              offset: message.offset,
            });
          }
        },
      });
    } catch (error) {
      logger.error(`Failed to connect Kafka consumer: ${error.message}`);
      this.isConnected = false;
      throw error;
    }
  }

  async disconnect() {
    try {
      await this.consumer.disconnect();
      this.isConnected = false;
      logger.info('Kafka consumer disconnected');
    } catch (error) {
      logger.error(`Error disconnecting consumer: ${error.message}`);
    }
  }
}

module.exports = new KafkaConsumer();

/src/models/fraudStorage.js
const sqlite3 = require('sqlite3').verbose();
const logger = require('../utils/logger');
const path = require('path');

class FraudStorage {
  constructor() {
    this.dbPath = path.join(__dirname, '../../data/frauds.db');
    this.db = new sqlite3.Database(this.dbPath);
    this.initializeDatabase();
  }

  initializeDatabase() {
    this.db.serialize(() => {
      this.db.run(`
        CREATE TABLE IF NOT EXISTS frauds (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          transactionId TEXT UNIQUE,
          userId TEXT,
          amount REAL,
          location TEXT,
          reasons TEXT,
          timestamp TEXT,
          detectedAt TEXT
        )
      `);
    });
  }

  async addFraud(fraudData) {
    return new Promise((resolve, reject) => {
      this.db.run(
        `INSERT INTO frauds 
        (transactionId, userId, amount, location, reasons, timestamp, detectedAt) 
        VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          fraudData.transactionId,
          fraudData.userId,
          fraudData.amount,
          fraudData.location,
          JSON.stringify(fraudData.reasons),
          fraudData.timestamp,
          new Date().toISOString(),
        ],
        function (error) {
          if (error) {
            logger.error('Error storing fraud', { error: error.message });
            reject(error);
          } else {
            resolve(this.lastID);
          }
        }
      );
    });
  }

  async getAllFrauds() {
    return new Promise((resolve, reject) => {
      this.db.all('SELECT * FROM frauds ORDER BY detectedAt DESC', (error, rows) => {
        if (error) {
          reject(error);
        } else {
          resolve(rows.map(row => ({
            ...row,
            reasons: JSON.parse(row.reasons),
          })));
        }
      });
    });
  }

  async getFraudsByUser(userId) {
    return new Promise((resolve, reject) => {
      this.db.all(
        'SELECT * FROM frauds WHERE userId = ? ORDER BY detectedAt DESC',
        [userId],
        (error, rows) => {
          if (error) {
            reject(error);
          } else {
            resolve(rows.map(row => ({
              ...row,
              reasons: JSON.parse(row.reasons),
            })));
          }
        }
      );
    });
  }
}

module.exports = new FraudStorage();

/src/routes/index.js
const express = require('express');
const router = express.Router();
const fraudController = require('../controllers/fraudController');

// Fraud routes
router.get('/frauds', fraudController.getAllFrauds);
router.get('/frauds/:userId', fraudController.getFraudsByUser);

// Health check
router.get('/health', fraudController.healthCheck);

module.exports = router;

/src/services/fraudDetectionService.js
const logger = require('../utils/logger');
const fraudStorage = require('../models/fraudStorage');
const NodeCache = require('node-cache');
const transactionCache = new NodeCache({ stdTTL: 10 }); // Cache for 10 seconds

class FraudDetectionService {
  constructor() {
    this.rules = [
      { name: 'highAmountForeign', fn: this.checkHighAmountForeign },
      { name: 'rapidTransactions', fn: this.checkRapidTransactions },
      { name: 'roundAmount', fn: this.checkRoundAmount },
    ];
  }

  async processTransaction(transaction) {
    try {
      const fraudReasons = [];
      
      // Check all fraud rules
      for (const rule of this.rules) {
        const result = await rule.fn(transaction);
        if (result.isFraud) {
          fraudReasons.push(rule.name);
        }
      }
      
      if (fraudReasons.length > 0) {
        const fraudData = {
          ...transaction,
          reasons: fraudReasons,
          timestamp: new Date().toISOString(),
        };
        
        // Log and store the fraud
        logger.warn('Fraud detected', {
          transactionId: transaction.transactionId,
          userId: transaction.userId,
          rule: fraudReasons.join(', '),
          message: `Fraud detected for transaction ${transaction.transactionId}`,
        });
        
        await fraudStorage.addFraud(fraudData);
      }
    } catch (error) {
      logger.error(`Error processing transaction: ${error.message}`, {
        transactionId: transaction.transactionId,
      });
      throw error;
    }
  }

  // Rule 1: Amount > $5000 and location is not "USA"
  checkHighAmountForeign(transaction) {
    const isFraud = transaction.amount > 5000 && transaction.location !== 'USA';
    return { isFraud };
  }

  // Rule 2: Multiple transactions from same userId in < 10 seconds
  checkRapidTransactions(transaction) {
    const userTransactions = transactionCache.get(transaction.userId) || [];
    
    // Check if there are previous transactions within 10 seconds
    const recentTransactions = userTransactions.filter(
      txn => new Date() - new Date(txn.timestamp) < 10000
    );
    
    const isFraud = recentTransactions.length > 0;
    
    // Update cache with current transaction
    transactionCache.set(transaction.userId, [...userTransactions, transaction]);
    
    return { isFraud };
  }

  // Rule 3: Amount is a round number divisible by 1000
  checkRoundAmount(transaction) {
    const isFraud = transaction.amount % 1000 === 0;
    return { isFraud };
  }
}

module.exports = new FraudDetectionService();

/src/utils/logger.js
const { createLogger, format, transports } = require('winston');
const { combine, timestamp, json, printf } = format;

// Custom format that includes transaction details for fraud logs
const fraudFormat = printf(({ level, message, timestamp, transactionId, userId, rule }) => {
  return JSON.stringify({
    timestamp,
    level,
    transactionId,
    userId,
    rule,
    message,
  });
});

const logger = createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: combine(
    timestamp(),
    json()
  ),
  transports: [
    new transports.Console(),
    new transports.File({ filename: 'logs/combined.log' }),
    new transports.File({ 
      filename: 'logs/fraud.log', 
      level: 'warn',
      format: fraudFormat
    }),
  ],
});

module.exports = logger;


/src/app.js
require('dotenv').config();
const express = require('express');
const logger = require('./utils/logger');
const config = require('./config');
const kafkaConsumer = require('./kafka/consumer');
const routes = require('./routes');

class App {
  constructor() {
    this.app = express();
    this.server = null;
    this.setupMiddlewares();
    this.setupRoutes();
  }

  setupMiddlewares() {
    this.app.use(express.json());
    this.app.use(express.urlencoded({ extended: true }));
    
    // Logging middleware
    this.app.use((req, res, next) => {
      logger.info(`${req.method} ${req.path}`);
      next();
    });
  }

  setupRoutes() {
    this.app.use('/', routes);
    
    // Error handling middleware
    this.app.use((err, req, res, next) => {
      logger.error('Unhandled error', { 
        error: err.message,
        stack: err.stack 
      });
      res.status(500).json({ error: 'Internal server error' });
    });
  }

  async start() {
    try {
      logger.info('Starting application...');
      
      // Connect to Kafka
      logger.info('Connecting to Kafka...');
      await kafkaConsumer.connect();
      
      // Start HTTP server
      this.server = this.app.listen(config.app.port, () => {
        logger.info(`Server running on port ${config.app.port}`);
      });
      
      // Keep the process alive
      process.on('SIGTERM', this.gracefulShutdown.bind(this));
      process.on('SIGINT', this.gracefulShutdown.bind(this));
      
      // Prevent immediate exit
      setInterval(() => {}, 1000);

    } catch (error) {
      logger.error('Failed to start application', { error: error.message });
      process.exit(1);
    }
  }

  async gracefulShutdown() {
    logger.info('Shutting down gracefully...');
    
    try {
      // Disconnect Kafka consumer
      await kafkaConsumer.disconnect();
      
      // Close HTTP server
      if (this.server) {
        this.server.close(() => {
          logger.info('Server closed');
        });
      }
    } catch (error) {
      logger.error('Error during shutdown', { error: error.message });
    } finally {
      process.exit(0);
    }
  }
}

// Start the application
const app = new App();
app.start().catch(err => {
  console.error('Fatal error during startup:', err);
  process.exit(1);
});


/test/services/fraudDetectionService.test.js
const fraudDetectionService = require('../../src/services/fraudDetectionService');

describe('Fraud Detection Service', () => {
  describe('checkHighAmountForeign', () => {
    it('should flag transactions > $5000 not in USA', () => {
      const transaction = {
        amount: 5001,
        location: 'Nigeria'
      };
      const result = fraudDetectionService.checkHighAmountForeign(transaction);
      expect(result.isFraud).toBe(true);
    });

    it('should not flag transactions <= $5000', () => {
      const transaction = {
        amount: 5000,
        location: 'Nigeria'
      };
      const result = fraudDetectionService.checkHighAmountForeign(transaction);
      expect(result.isFraud).toBe(false);
    });

    it('should not flag US transactions regardless of amount', () => {
      const transaction = {
        amount: 10000,
        location: 'USA'
      };
      const result = fraudDetectionService.checkHighAmountForeign(transaction);
      expect(result.isFraud).toBe(false);
    });
  });

  describe('checkRoundAmount', () => {
    it('should flag amounts divisible by 1000', () => {
      const transaction = { amount: 1000 };
      const result = fraudDetectionService.checkRoundAmount(transaction);
      expect(result.isFraud).toBe(true);
    });

    it('should not flag amounts not divisible by 1000', () => {
      const transaction = { amount: 1001 };
      const result = fraudDetectionService.checkRoundAmount(transaction);
      expect(result.isFraud).toBe(false);
    });
  });
});

/.dockerignore
node_modules/

/docker-compose.yml
version: '3.8'

services:
  fraud-detection:
    build: .
    ports:
      - "3000:3000"
    volumes:
      - ./data:/usr/src/app/data
      - ./logs:/usr/src/app/logs
    environment:
      - KAFKA_BROKERS=kafka:9092
      - NODE_ENV=production
    depends_on:
      kafka:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "node", "healthcheck.js"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    restart: unless-stopped

  zookeeper:
    image: confluentinc/cp-zookeeper:7.0.1
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
    ports:
      - "2181:2181"
    healthcheck:
      test: ["CMD", "zkOk.sh"]
      interval: 10s
      timeout: 5s
      retries: 3

  kafka:
    image: confluentinc/cp-kafka:7.0.1
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
      - "29092:29092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092,PLAINTEXT_HOST://localhost:29092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_AUTO_CREATE_TOPICS_ENABLE: "true"
    healthcheck:
      test: ["CMD", "kafka-topics", "--bootstrap-server", "kafka:9092", "--list"]
      interval: 10s
      timeout: 5s
      retries: 3

/Dockerfile
# Use official Node.js image
FROM node:18-alpine

# Create app directory
WORKDIR /usr/src/app

# Copy package files first for better caching
COPY package*.json ./
COPY .env ./

# Install dependencies
RUN npm install

# Bundle app source
COPY . .

# Create required directories
RUN mkdir -p /usr/src/app/data /usr/src/app/logs

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD node healthcheck.js || exit 1

# Expose port
EXPOSE 3000

# Start command
CMD ["npm", "start"]

/package.json
{
  "name": "frau-detection",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "node src/app.js",
    "dev": "nodemon src/app.js",
    "test": "jest",
    "docker:up": "docker-compose up -d",
    "docker:down": "docker-compose down",
    "docker:logs": "docker-compose logs -f",
    "docker:rebuild": "docker-compose down && docker-compose up --build -d"
},
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "dotenv": "^17.2.1",
    "express": "^5.1.0",
    "kafkajs": "^2.2.4",
    "node-cache": "^5.1.2",
    "sqlite3": "^5.1.7",
    "winston": "^3.17.0"
  },
  "devDependencies": {
    "jest": "^30.0.5",
    "nodemon": "^3.1.10",
    "supertest": "^7.1.4"
  }
}

/produce-transaction.js
const { Kafka } = require('kafkajs');
const config = require('./src/config');

const kafka = new Kafka({
  brokers: ['localhost:29092'],
  clientId: 'transaction-producer'
});

const producer = kafka.producer();

async function sendTransaction(transaction) {
  await producer.connect();
  await producer.send({
    topic: config.kafka.topicTransactions,
    messages: [{ value: JSON.stringify(transaction) }]
  });
  console.log(`Sent transaction: ${transaction.transactionId}`);
  await producer.disconnect();
}

// Example transactions (including fraud cases)
const transactions = [
  // Fraud: High amount + non-USA location
  { transactionId: 'txn_f1', userId: 'user_1', amount: 6000, location: 'Nigeria', timestamp: new Date().toISOString() },
  
  // Fraud: Round number amount
  { transactionId: 'txn_f2', userId: 'user_2', amount: 1000, location: 'USA', timestamp: new Date().toISOString() },
  { transactionId: 'txn_f3', userId: 'user_2', amount: 2000, location: 'USA', timestamp: new Date().toISOString() },
  { transactionId: 'txn_f4', userId: 'user_2', amount: 4000, location: 'USA', timestamp: new Date().toISOString() },
  { transactionId: 'txn_f5', userId: 'user_2', amount: 5000, location: 'USA', timestamp: new Date().toISOString() },
  { transactionId: 'txn_f6', userId: 'user_2', amount: 5000, location: 'USA', timestamp: new Date().toISOString() },
  { transactionId: 'txn_f7', userId: 'user_2', amount: 5000, location: 'USA', timestamp: new Date().toISOString() },
  { transactionId: 'txn_f8', userId: 'user_2', amount: 5000, location: 'USA', timestamp: new Date().toISOString() },
  { transactionId: 'txn_f9', userId: 'user_2', amount: 5000, location: 'USA', timestamp: new Date().toISOString() },
  { transactionId: 'txn_f10', userId: 'user_2', amount: 5000, location: 'USA', timestamp: new Date().toISOString() },
  { transactionId: 'txn_f11', userId: 'user_2', amount: 5000, location: 'USA', timestamp: new Date().toISOString() },
  
  // Normal transaction
  { transactionId: 'txn_n12', userId: 'user_3', amount: 1234, location: 'USA', timestamp: new Date().toISOString() }
];

// Send all transactions
Promise.all(transactions.map(sendTransaction)).catch(console.error);

module.exports = {sendTransaction};


